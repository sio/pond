package main

import (
	"github.com/sio/pond/metal_id"

	"crypto"
	"flag"
	"fmt"
	"os"
	"path/filepath"
)

func main() {
	// Runtime checks
	checkOS()
	if os.Geteuid() != 0 {
		stderr("WARNING: When running as non-root some data sources will not be available.")
		stderr("WARNING: Hardware derived key will not match the one generated by root.")
	}

	// Parse CLI arguments
	verbose := flag.Bool("verbose", false, "print some information about fingerprint data (safe)")
	unsafe := flag.Bool("unsafe", false, "print non-obfuscated debug information (unsafe)")
	dest := flag.String("output", "", `private key destination path`)
	paranoid := flag.Bool("paranoid", false, "use extra paranoid data sources for fingerprinting")
	flag.Parse()
	var err error
	if len(*dest) > 0 {
		dir := filepath.Dir(*dest)
		if _, err = os.Stat(dir); os.IsNotExist(err) {
			fail("Destination directory does not exist: %s", dir)
		}
	}
	if *unsafe {
		*verbose = true
	}
	debug := func(format string, a ...any) {
		if !(*verbose) {
			return
		}
		stderr(format, a...)
	}

	// Derive key from hardware fingerprint
	src := metal_id.Sources()
	if *paranoid {
		src = metal_id.SourcesParanoid()
	}
	var hwid = metal_id.New(debug, previewSeed(*unsafe))
	err = hwid.Fetch(src)
	if err != nil {
		fail("Error: %v", err)
	}
	var key crypto.Signer
	key, err = hwid.Key()
	if err != nil {
		fail("Failed to generate machine key: %v", err)
	}

	// Print public key to standard output
	var output []byte
	output, err = metal_id.EncodePublicKey(key.Public())
	if err != nil {
		fail("Failed to serialize public key: %v", err)
	}
	fmt.Println(string(output))

	// Save keys to file system
	if len(*dest) == 0 {
		return
	}
	err = os.WriteFile(*dest+".pub", output, 0644)
	if err != nil {
		fail("Failed to save public key: %v", err)
	}
	output, err = metal_id.EncodePrivateKey(key)
	if err != nil {
		fail("Failed to serialize private key: %v", err)
	}
	err = os.WriteFile(*dest, output, 0600)
	if err != nil {
		fail("Failed to save private key: %v", err)
	}
}
